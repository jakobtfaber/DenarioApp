"""
--- AUTO-GENERATED DOCSTRING ---
Table of content is automatically generated by Agent Docstrings v1.3.5

Classes/Functions:
    - description_comp(den: Denario) -> None (line 29)
    - idea_comp(den: Denario) -> None (line 62)
    - method_comp(den: Denario) -> None (line 216)
    - results_comp(den: Denario) -> None (line 354)
    - paper_comp(den: Denario) -> None (line 558)
    - check_idea_comp(den: Denario) -> None (line 691)
    - keywords_comp(den: Denario) -> None (line 775)
--- END AUTO-GENERATED DOCSTRING ---
"""

from pathlib import Path
from PIL import Image
import streamlit as st
import json
import os
from streamlit_pdf_viewer import pdf_viewer
from denario import Denario, Journal
from denario import models
from denario.utils import WolframAlphaClient
try:
    from .utils import show_markdown_file, create_zip_in_memory, stream_to_streamlit
    from .constants import RAG_PROVIDERS
except Exception:
    # Fallback for script-mode import
    from utils import show_markdown_file, create_zip_in_memory, stream_to_streamlit
    from constants import RAG_PROVIDERS

# ---
# Components
# ---


def _get_domain_context(provider: str) -> str:
    """Get domain-specific context based on the selected provider."""
    if "Planck" in provider:
        return """Planck Mission Context:
- Planck 2018 results: cosmological parameters from CMB temperature and polarization
- Key datasets: Planck 2018 TT,TE,EE+lowE+lensing+BAO
- Relevant parameters: H0, Ωm, ΩΛ, ns, As, τ
- Recent constraints: H0 = 67.4 ± 0.5 km/s/Mpc (Planck 2018)
- Lensing potential: Planck lensing reconstruction
- Systematics: foreground contamination, beam uncertainties"""

    elif "CAMB" in provider:
        return """CAMB (Code for Anisotropies in the Microwave Background) Context:
- Boltzmann solver for CMB anisotropies and matter power spectra
- Key features: scalar, vector, tensor modes; dark energy models
- Recent updates: CAMB 1.3+ with improved precision
- Applications: parameter estimation, likelihood analysis
- Integration: CosmoMC, MontePython, Cobaya
- Outputs: Cl, P(k), transfer functions"""

    elif "CLASSY" in provider:
        return """CLASSY (Cosmic Linear Anisotropy Solving System) Context:
- Alternative to CAMB for CMB and LSS calculations
- Features: high precision, modular design, dark energy models
- Recent work: CLASSY-SZ for Sunyaev-Zel'dovich effects
- Applications: parameter estimation, model comparison
- Integration: MontePython, Cobaya
- Advantages: speed, flexibility, extended models"""

    else:
        return "Domain-specific context not available for this provider."


def _retrieve_with_unified_adapter(
        provider: str,
        query: str,
        max_results: int = 5) -> tuple:
    """Retrieve results using unified RAG adapter with fallback."""
    try:
        from .rag_adapter import get_unified_rag_adapter, format_results_for_ui

        # Get unified adapter
        adapter = get_unified_rag_adapter()

        # Get provider info
        provider_info = adapter.get_provider_info(provider)

        # Retrieve results with fallback
        results = adapter.retrieve_with_fallback(query, provider, max_results)

        return results, provider_info, None

    except Exception as e:
        return [], {"name": "Unknown", "available": False}, str(e)


def description_comp(den: Denario) -> None:

    st.header("Data description")

    data_descr = st.text_area(
        "Describe the data and tools to be used in the project. You may also "
        "include information about the computing resources required.",
        placeholder="E.g. Analyze the experimental data stored in /path/to/data.csv "
        "using sklearn and pandas. This data includes time-series measurements "
        "from a particle detector.",
        key="data_descr",
        height=100,
    )

    uploaded_file = st.file_uploader(
        "Alternatively, upload a file with the data description in markdown "
        "format.",
        accept_multiple_files=False,
    )

    if uploaded_file:
        content = uploaded_file.read().decode("utf-8")
        den.set_data_description(content)

    if data_descr:

        den.set_data_description(data_descr)

    st.markdown("### Current data description")

    try:
        show_markdown_file(
            den.project_dir + "/input_files/data_description.md",
            label="data description",
        )
    except FileNotFoundError:
        st.write("Data description not set.")


def idea_comp(den: Denario) -> None:

    st.header("Research idea")
    st.write("Generate a research idea provided the data description.")

    st.write(
        "Choose between a fast generation process or a more involved one using "
        "planning and control through [cmbagent](https://github.com/CMBAgents/cmbagent).")

    fast = st.toggle("Fast generation", value=True, key="fast_toggle_idea")

    model_keys = list(models.keys())

    if fast:

        default_fast_idea_index = model_keys.index("gemini-2.0-flash")

        st.caption("Choose a LLM model for the fast generation")
        llm_model = st.selectbox(
            "LLM Model",
            model_keys,
            index=default_fast_idea_index,
            key="llm_model_idea",
        )

    else:

        # Get index of desired default models
        default_idea_maker_index = model_keys.index("gpt-4o")
        default_idea_hater_index = model_keys.index("claude-3.7-sonnet")

        # Add model selection dropdowns
        col1, col2 = st.columns(2)
        with col1:
            st.caption(
                "Idea Maker: Generates and selects the best research ideas based on "
                "the data description")
            idea_maker_model = st.selectbox(
                "Idea Maker Model",
                model_keys,
                index=default_idea_maker_index,
                key="idea_maker_model",
            )
        with col2:
            st.caption(
                "Idea Hater: Critiques ideas and proposes recommendations for "
                "improvement"
            )
            idea_hater_model = st.selectbox(
                "Idea Hater Model",
                model_keys,
                index=default_idea_hater_index,
                key="idea_hater_model",
            )

    if not fast:
        # Add planner and plan reviewer model selection dropdowns
        col3, col4 = st.columns(2)
        with col3:
            st.caption(
                "Planner: Creates a detailed plan for generating research ideas"
            )
            planner_model = st.selectbox(
                "Planner Model",
                model_keys,
                index=model_keys.index("gpt-4o"),
                key="planner_model_idea",
            )
        with col4:
            st.caption(
                "Plan Reviewer: Reviews and improves the generated plan"
            )
            plan_reviewer_model = st.selectbox(
                "Plan Reviewer Model",
                model_keys,
                index=model_keys.index("claude-3.7-sonnet"),
                key="plan_reviewer_model_idea",
            )

    # Initialize session state for tracking operations
    if "idea_running" not in st.session_state:
        st.session_state.idea_running = False

    col1, col2 = st.columns([1, 1])
    with col1:
        press_button = st.button(
            "Generate",
            type="primary",
            key="get_idea",
            disabled=st.session_state.idea_running,
        )
    with col2:
        stop_button = st.button(
            "Stop",
            type="secondary",
            key="stop_idea",
            disabled=not st.session_state.idea_running,
        )

    # Add custom CSS for red border on stop button
    st.markdown(
        """
        <style>
        div[data-testid="column"]:nth-of-type(2) button {
            border: 2px solid #ff4444 !important;
            color: #ff4444 !important;
        }
        div[data-testid="column"]:nth-of-type(2) button:hover {
            background-color: #ff4444 !important;
            color: white !important;
        }
        </style>
    """,
        unsafe_allow_html=True,
    )

    if press_button and not st.session_state.idea_running:
        st.session_state.idea_running = True
        st.rerun()

    if stop_button and st.session_state.idea_running:
        st.session_state.idea_running = False
        st.warning("Operation stopped by user.")
        st.rerun()

    if st.session_state.idea_running:
        with st.spinner("Generating research idea...", show_time=True):
            log_box = st.empty()

            # Redirect console output to app
            with stream_to_streamlit(log_box):
                try:
                    if fast:
                        den.get_idea_fast(llm=llm_model, verbose=True)
                    else:
                        den.get_idea(
                            idea_maker_model=models[idea_maker_model],
                            idea_hater_model=models[idea_hater_model],
                            planner_model=models[planner_model],
                            plan_reviewer_model=models[plan_reviewer_model],
                        )

                    if (
                        st.session_state.idea_running
                    ):  # Only show success if not stopped
                        st.success("Done!")

                        # --- HITL: Idea Review ---
                        st.markdown("---")
                        st.write("**Review and edit the generated idea:**")
                        try:
                            idea_path = den.project_dir + "/input_files/idea.md"
                            with open(idea_path, 'r') as f:
                                current_idea = f.read()

                            # Store idea in session state to prevent clearing
                            # on download
                            if "current_idea_content" not in st.session_state:
                                st.session_state.current_idea_content = current_idea

                            edited_idea = st.text_area(
                                "Edit the research idea",
                                value=st.session_state.current_idea_content,
                                height=200,
                                key="idea_review_area",
                                help="Review and modify the generated research idea before proceeding")

                            # Update session state when user types
                            st.session_state.current_idea_content = edited_idea

                            col_a, col_b = st.columns([1, 3])
                            with col_a:
                                if st.button(
                                        "Accept idea", key="accept_idea_btn"):
                                    # Save the edited idea
                                    with open(idea_path, 'w') as f:
                                        f.write(edited_idea)
                                    den.set_idea(edited_idea)
                                    st.success("Idea updated successfully!")
                                    st.rerun()

                            with col_b:
                                if st.button(
                                        "Reset to original", key="reset_idea_btn"):
                                    st.rerun()

                        except Exception as e:
                            st.warning(f"Idea review UI error: {str(e)}")

                except Exception as e:
                    st.error(f"Error: {str(e)}")
                finally:
                    st.session_state.idea_running = False

    uploaded_file = st.file_uploader(
        "Choose a file with the research idea", accept_multiple_files=False
    )

    if uploaded_file:
        content = uploaded_file.read().decode("utf-8")
        den.set_idea(content)

    try:
        idea_path = den.project_dir + "/input_files/idea.md"
        if os.path.exists(idea_path):
            with open(idea_path, 'r') as f:
                idea_content = f.read()

            # Store in session state for persistence
            if "current_idea_content" not in st.session_state:
                st.session_state.current_idea_content = idea_content

            # Display the idea content
            st.markdown("### Current research idea")
            st.markdown(st.session_state.current_idea_content)

            # Show edit option
            st.markdown("**Edit the research idea:**")
            edited_idea = st.text_area(
                "Edit the research idea",
                value=st.session_state.current_idea_content,
                height=200,
                key="idea_edit_area",
                help="Review and modify the research idea"
            )

            # Update session state when user types
            st.session_state.current_idea_content = edited_idea

            col_a, col_b = st.columns([1, 3])
            with col_a:
                if st.button("Save changes", key="save_idea_btn"):
                    # Save the edited idea
                    with open(idea_path, 'w') as f:
                        f.write(edited_idea)
                    den.set_idea(edited_idea)
                    st.success("Idea updated successfully!")
                    st.rerun()
            with col_b:
                if st.button("Reset to original", key="reset_idea_btn"):
                    # Reset to original content
                    st.session_state.current_idea_content = idea_content
                    st.rerun()
        else:
            st.write("Idea not generated or uploaded.")
    except Exception as e:
        st.write(f"Error loading idea: {e}")
        st.write("Idea not generated or uploaded.")


def method_comp(den: Denario) -> None:

    st.header("Methods")
    st.write(
        "Generate the methods to be employed in the computation of the results, provided the idea and data description."
    )

    st.write(
        "Choose between a fast generation process or a more involved one using planning and control through [cmbagent](https://github.com/CMBAgents/cmbagent)."
    )

    fast = st.toggle("Fast generation", value=True, key="fast_toggle_method")

    model_keys = list(models.keys())

    default_fast_method_index = model_keys.index("gemini-2.0-flash")

    if fast:

        st.caption("Choose a LLM model for the fast generation")
        llm_model = st.selectbox(
            "LLM Model",
            model_keys,
            index=default_fast_method_index,
            key="llm_model_method",
        )

    else:

        default_planner_index = model_keys.index("gpt-4o")
        default_plan_reviewer_index = model_keys.index("claude-3.7-sonnet")
        default_method_generator_index = model_keys.index("gpt-4o")

        col1, col2 = st.columns(2)
        with col1:
            st.caption(
                "Planner: Creates a detailed plan for generating research methodology"
            )
            planner_model = st.selectbox(
                "Planner Model",
                model_keys,
                index=default_planner_index,
                key="planner_model_method",
            )
        with col2:
            st.caption(
                "Plan Reviewer: Reviews and improves the generated methodology plan"
            )
            plan_reviewer_model = st.selectbox(
                "Plan Reviewer Model",
                model_keys,
                index=default_plan_reviewer_index,
                key="plan_reviewer_model_method",
            )
        col3, col4 = st.columns(2)
        with col3:
            st.caption("Method Generator: Generates the methodology")
            method_generator_model = st.selectbox(
                "Method Generator Model",
                model_keys,
                index=default_method_generator_index,
                key="method_generator_model",
            )
    # Initialize session state for tracking operations
    if "method_running" not in st.session_state:
        st.session_state.method_running = False

    col1, col2 = st.columns([1, 1])
    with col1:
        press_button = st.button(
            "Generate",
            type="primary",
            key="get_method",
            disabled=st.session_state.method_running,
        )
    with col2:
        stop_button = st.button(
            "Stop",
            type="secondary",
            key="stop_method",
            disabled=not st.session_state.method_running,
        )

    # Add custom CSS for red border on stop button
    st.markdown(
        """
        <style>
        div[data-testid="column"]:nth-of-type(2) button {
            border: 2px solid #ff4444 !important;
            color: #ff4444 !important;
        }
        div[data-testid="column"]:nth-of-type(2) button:hover {
            background-color: #ff4444 !important;
            color: white !important;
        }
        </style>
    """,
        unsafe_allow_html=True,
    )

    if press_button and not st.session_state.method_running:
        st.session_state.method_running = True
        st.rerun()

    if stop_button and st.session_state.method_running:
        st.session_state.method_running = False
        st.warning("Operation stopped by user.")
        st.rerun()

    if st.session_state.method_running:
        with st.spinner("Generating methods...", show_time=True):
            log_box = st.empty()

            # Redirect console output to app
            with stream_to_streamlit(log_box):
                try:
                    if fast:
                        den.get_method_fast(llm=llm_model, verbose=True)
                    else:
                        den.get_method(
                            planner_model=models[planner_model],
                            plan_reviewer_model=models[plan_reviewer_model],
                            method_generator_model=models[
                                method_generator_model
                            ],
                        )

                    if (
                        st.session_state.method_running
                    ):  # Only show success if not stopped
                        st.success("Done!")

                        # --- HITL: Method Review ---
                        st.markdown("---")
                        st.write(
                            "**Review and edit the generated methodology:**")
                        try:
                            method_path = den.project_dir + "/input_files/methods.md"
                            with open(method_path, 'r') as f:
                                current_method = f.read()

                            edited_method = st.text_area(
                                "Edit the methodology",
                                value=current_method,
                                height=300,
                                key="method_review_area",
                                help="Review and modify the generated methodology before proceeding"
                            )

                            col_a, col_b = st.columns([1, 3])
                            with col_a:
                                if st.button(
                                        "Accept method", key="accept_method_btn"):
                                    # Save the edited method
                                    with open(method_path, 'w') as f:
                                        f.write(edited_method)
                                    den.set_method(edited_method)
                                    st.success(
                                        "Methodology updated successfully!")
                                    st.rerun()

                            with col_b:
                                if st.button(
                                        "Reset to original", key="reset_method_btn"):
                                    st.rerun()

                        except Exception as e:
                            st.warning(f"Method review UI error: {str(e)}")

                except Exception as e:
                    st.error(f"Error: {str(e)}")
                finally:
                    st.session_state.method_running = False

    uploaded_file = st.file_uploader(
        "Choose a file with the research methods", accept_multiple_files=False
    )

    if uploaded_file:
        content = uploaded_file.read().decode("utf-8")
        den.set_method(content)

    try:
        show_markdown_file(
            den.project_dir + "/input_files/methods.md", label="methods"
        )
    except FileNotFoundError:
        st.write("Methods not generated or uploaded.")


def results_comp(den: Denario) -> None:

    st.header("Results")
    st.write(
        "Compute the results, given the methods, idea and data description."
    )

    model_keys = list(models.keys())

    # Get index of desired default models
    default_researcher_index = model_keys.index("gemini-2.5-pro")
    default_engineer_index = model_keys.index("gemini-2.5-pro")

    # Add model selection dropdowns
    col1, col2 = st.columns(2)
    with col1:
        st.caption("Engineer: Generates the code to compute the results")
        engineer_model = st.selectbox(
            "Engineer Model",
            model_keys,
            index=default_engineer_index,
            key="engineer_model",
        )
    with col2:
        st.caption(
            "Researcher: processes the results and writes the results report"
        )
        researcher_model = st.selectbox(
            "Researcher Model",
            model_keys,
            index=default_researcher_index,
            key="researcher_model",
        )

    # add option dropdown for restart at step
    with st.expander("Options for the results generation"):
        restart_at_step = st.number_input(
            "Restart at step", min_value=0, max_value=100, value=0
        )

        hardware_constraints = st.text_input(
            "Hardware constraints", placeholder="cpu:2, ram:16g, gpu:1"
        )

        default_planner_index = model_keys.index("gpt-4o")
        default_plan_reviewer_index = model_keys.index("claude-3.7-sonnet")

        # add options to control planner, plan_reviewer, researcher and
        # engineer models
        col1, col2 = st.columns(2)
        with col1:
            st.caption(
                "Planner: Creates a detailed plan for generating research results"
            )
            planner_model = st.selectbox(
                "Planner Model",
                model_keys,
                index=default_planner_index,
                key="planner_model_results",
            )
        with col2:
            st.caption("Plan Reviewer: Reviews and improves the proposed plan")
            plan_reviewer_model = st.selectbox(
                "Plan Reviewer Model",
                model_keys,
                index=default_plan_reviewer_index,
                key="plan_reviewer_model_results",
            )

        # set max n attempts
        max_n_attempts = st.number_input(
            "Max number of code execution attempts",
            min_value=1,
            max_value=10,
            value=6,
        )

        # max n steps
        max_n_steps = st.number_input(
            "Max number of steps", min_value=1, max_value=10, value=6
        )

    # Initialize session state for tracking operations
    if "results_running" not in st.session_state:
        st.session_state.results_running = False

    col1, col2 = st.columns([1, 1])
    with col1:
        press_button = st.button(
            "Generate",
            type="primary",
            key="get_results",
            disabled=st.session_state.results_running,
        )
    with col2:
        stop_button = st.button(
            "Stop",
            type="secondary",
            key="stop_results",
            disabled=not st.session_state.results_running,
        )

    # Add custom CSS for red border on stop button
    st.markdown(
        """
        <style>
        div[data-testid="column"]:nth-of-type(2) button {
            border: 2px solid #ff4444 !important;
            color: #ff4444 !important;
        }
        div[data-testid="column"]:nth-of-type(2) button:hover {
            background-color: #ff4444 !important;
            color: white !important;
        }
        </style>
    """,
        unsafe_allow_html=True,
    )

    if press_button and not st.session_state.results_running:
        st.session_state.results_running = True
        st.rerun()

    if stop_button and st.session_state.results_running:
        st.session_state.results_running = False
        st.warning("Operation stopped by user.")
        st.rerun()

    if st.session_state.results_running:
        with st.spinner("Computing results...", show_time=True):
            log_box = st.empty()

            # Redirect console output to app
            with stream_to_streamlit(log_box):
                try:
                    den.get_results(
                        engineer_model=models[engineer_model],
                        researcher_model=models[researcher_model],
                        restart_at_step=restart_at_step,
                        hardware_constraints=hardware_constraints,
                        planner_model=models[planner_model],
                        plan_reviewer_model=models[plan_reviewer_model],
                        max_n_attempts=max_n_attempts,
                        max_n_steps=max_n_steps,
                    )

                    if (
                        st.session_state.results_running
                    ):  # Only show success if not stopped
                        st.success("Done!")
                except Exception as e:
                    st.error(f"Error: {str(e)}")
                finally:
                    st.session_state.results_running = False

    uploaded_files = st.file_uploader(
        "Upload markdown file and/or plots from the results of the research",
        accept_multiple_files=True,
    )

    if uploaded_files:
        plots = []
        for file in uploaded_files:
            if file.name.endswith(".md"):
                content = file.read().decode("utf-8")
                den.set_results(content)
            else:
                plots.append(Image.open(file))
        den.set_plots(plots)

    plots = list(Path(den.project_dir + "/input_files/plots").glob("*"))

    num_plots = len(list(plots))

    if num_plots > 0:
        plots_cols = st.columns(num_plots)

        for i, plot in enumerate(plots):
            with plots_cols[i]:
                st.image(plot, caption=plot.name)

        plots_zip = create_zip_in_memory(
            den.project_dir + "/input_files/plots"
        )

        st.download_button(
            label="Download plots",
            data=plots_zip,
            file_name="plots.zip",
            mime="application/zip",
            icon=":material/download:",
        )

    else:
        st.write("Plots not generated or uploaded.")

    try:

        codes_zip = create_zip_in_memory(
            den.project_dir + "/experiment_generation_output"
        )

        st.download_button(
            label="Download codes",
            data=codes_zip,
            file_name="codes.zip",
            mime="application/zip",
            icon=":material/download:",
        )

        show_markdown_file(
            den.project_dir + "/input_files/results.md",
            label="results summary",
        )

    except FileNotFoundError:
        st.write("Results not generated or uploaded.")


def paper_comp(den: Denario) -> None:

    st.header("Article")
    st.write("Write the article using the computed results of the research.")

    with st.expander("Options for the paper writing agents"):

        st.caption("Choose a LLM model for the paper generation")
        llm_model = st.selectbox(
            "LLM Model", models.keys(), index=0, key="llm_model_paper"
        )

        selected_journal = st.selectbox(
            "Choose the journal for the latex style:",
            [j.value for j in Journal],
            index=0,
            key="journal_select",
        )

        citations = st.toggle(
            "Add citations", value=True, key="toggle_citations"
        )

        writer = st.text_input(
            "Describe the type of researcher e.g. cosmologist, biologist... Default is 'scientist'.",
            placeholder="scientist",
            key="writer_type",
            value="scientist",
        )

    # Initialize session state for tracking operations
    if "paper_running" not in st.session_state:
        st.session_state.paper_running = False

    col1, col2 = st.columns([1, 1])
    with col1:
        press_button = st.button(
            "Generate",
            type="primary",
            key="get_paper",
            disabled=st.session_state.paper_running,
        )
    with col2:
        stop_button = st.button(
            "Stop",
            type="secondary",
            key="stop_paper",
            disabled=not st.session_state.paper_running,
        )

    # Add custom CSS for red border on stop button
    st.markdown(
        """
        <style>
        div[data-testid="column"]:nth-of-type(2) button {
            border: 2px solid #ff4444 !important;
            color: #ff4444 !important;
        }
        div[data-testid="column"]:nth-of-type(2) button:hover {
            background-color: #ff4444 !important;
            color: white !important;
        }
        </style>
    """,
        unsafe_allow_html=True,
    )

    if press_button and not st.session_state.paper_running:
        st.session_state.paper_running = True
        st.rerun()

    if stop_button and st.session_state.paper_running:
        st.session_state.paper_running = False
        st.warning("Operation stopped by user.")
        st.rerun()

    if st.session_state.paper_running:
        with st.spinner("Writing the paper...", show_time=True):
            # log_box = st.empty()

            # Redirect console output to app
            # with stream_to_streamlit(log_box):
            try:
                den.get_paper(
                    journal=selected_journal,
                    llm=llm_model,
                    writer=writer,
                    add_citations=citations,
                )

                if (
                    st.session_state.paper_running
                ):  # Only show success if not stopped
                    st.success("Done!")
                    st.balloons()
            except Exception as e:
                st.error(f"Error: {str(e)}")
            finally:
                st.session_state.paper_running = False

    try:

        texfile = den.project_dir + "/paper/paper_v4_final.tex"

        # Ensure that the .tex has been created and we can read it
        with open(texfile, "r") as f:
            f.read()

        paper_zip = create_zip_in_memory(den.project_dir + "/paper")

        st.download_button(
            label="Download latex files",
            data=paper_zip,
            file_name="paper.zip",
            mime="application/zip",
            icon=":material/download:",
        )

    except FileNotFoundError:
        st.write("Latex not generated yet.")

    try:

        pdffile = den.project_dir + "/paper/paper_v4_final.pdf"

        with open(pdffile, "rb") as pdf_file:
            PDFbyte = pdf_file.read()

        st.download_button(
            label="Download pdf",
            data=PDFbyte,
            file_name="paper.pdf",
            mime="application/octet-stream",
            icon=":material/download:",
        )

        pdf_viewer(pdffile)

    except FileNotFoundError:
        st.write("Pdf not generated yet.")


def check_idea_comp(den: Denario) -> None:

    st.header("Check idea")
    st.write(
        "Check if the research idea has been investigated in previous literature."
    )

    fast = st.toggle(
        "Fast generation", value=True, key="fast_toggle_check_idea"
    )

    # Retrieval provider selection (Perplexity vs Domain RAG)
    colp, _ = st.columns([2, 1])
    with colp:
        provider = st.selectbox(
            "Retrieval provider",
            RAG_PROVIDERS,
            index=0,
            key="rag_provider_check_idea",
            help="Perplexity = web academic search; Domain = Planck/CAMB/CLASSY sources",
        )

    try:
        den.set_idea()
        idea = den.research.idea

        # show current idea
        st.markdown("### Current idea")
        st.write(idea)

        # Initialize session state for tracking operations
        if "literature_running" not in st.session_state:
            st.session_state.literature_running = False

        col1, col2 = st.columns([1, 1])
        with col1:
            press_button = st.button(
                "Literature search",
                type="primary",
                key="get_literature",
                disabled=st.session_state.literature_running,
            )
        with col2:
            stop_button = st.button(
                "Stop",
                type="secondary",
                key="stop_literature",
                disabled=not st.session_state.literature_running,
            )

        # Add custom CSS for red border on stop button
        st.markdown(
            """
            <style>
            div[data-testid="column"]:nth-of-type(2) button {
                border: 2px solid #ff4444 !important;
                color: #ff4444 !important;
            }
            div[data-testid="column"]:nth-of-type(2) button:hover {
                background-color: #ff4444 !important;
                color: white !important;
            }
            </style>
        """,
            unsafe_allow_html=True,
        )

        if press_button and not st.session_state.literature_running:
            st.session_state.literature_running = True
            st.rerun()

        if stop_button and st.session_state.literature_running:
            st.session_state.literature_running = False
            st.warning("Operation stopped by user.")
            st.rerun()

        if st.session_state.literature_running:
            with st.spinner(
                "Searching for previous literature...", show_time=True
            ):
                log_box = st.empty()

                # Redirect console output to app
                with stream_to_streamlit(log_box):
                    try:
                        # Use unified RAG adapter for all providers
                        query = den.research.idea if hasattr(
                            den.research, 'idea') else "cosmology research"
                        results, provider_info, error = _retrieve_with_unified_adapter(
                            provider, query, 5)

                        if error:
                            st.error(f"RAG retrieval error: {error}")
                            # Fallback to regular check_idea
                            if fast:
                                result = den.check_idea_fast(verbose=True)
                            else:
                                result = den.check_idea()
                        else:
                            # Show provider info
                            if provider_info.get("available"):
                                if provider_info.get("corpus_stats"):
                                    stats = provider_info["corpus_stats"]
                                    st.info(
                                        f"{
                                            provider_info['name']}: {
                                            stats['documents']} documents, {
                                            stats['entities']} entities indexed")
                                else:
                                    st.info(f"Using {provider_info['name']}")
                            else:
                                st.warning(
                                    f"{provider_info['name']} not available, using fallback")

                            if results:
                                # Display results in expandable format
                                st.write(
                                    f"**Relevant documents from {provider_info['name']}:**")
                                for i, result in enumerate(results, 1):
                                    with st.expander(f"{i}. {result.title} (score: {result.score:.2f})"):
                                        st.write(f"**URL:** {result.url}")
                                        if result.doi:
                                            st.write(
                                                f"**DOI:** https://doi.org/{result.doi}")
                                        if result.metadata.get("authors"):
                                            authors = result.metadata["authors"][:3]
                                            st.write(
                                                f"**Authors:** {', '.join(authors)}")
                                            if len(
                                                    result.metadata["authors"]) > 3:
                                                st.write(
                                                    f"({len(result.metadata['authors'])} total authors)")
                                        if result.metadata.get("categories"):
                                            st.write(
                                                f"**Categories:** {', '.join(result.metadata['categories'][:2])}")
                                        if result.metadata.get("entities"):
                                            st.write(
                                                f"**Key terms:** {', '.join(result.metadata['entities'][:5])}")
                                        st.write(
                                            f"**Content preview:** {result.content[:500]}...")

                                # Format as literature search result
                                from .rag_adapter import format_results_for_ui
                                result = format_results_for_ui(results)
                            else:
                                result = f"No relevant documents found using {
                                    provider_info['name']}."

                        st.write(result)

                        # Legacy fallback for specific providers (kept for
                        # compatibility)
                        if provider.startswith("Perplexity") and not results:
                            # Web RAG via Perplexity, fast or planned
                            if fast:
                                result = den.check_idea_fast(verbose=True)
                            else:
                                result = den.check_idea()
                        elif "GraphRAG" in provider and not results:
                            # GraphRAG path (local corpus)
                            try:
                                from .graphrag import get_graphrag_retriever

                                # Get GraphRAG retriever
                                retriever = get_graphrag_retriever()

                                # Show corpus stats
                                stats = retriever.get_corpus_stats()
                                st.info(
                                    f"GraphRAG: {
                                        stats['documents']} documents, {
                                        stats['entities']} entities indexed")

                                # Retrieve relevant documents
                                query = den.research.idea if hasattr(
                                    den.research, 'idea') else "cosmology research"
                                results = retriever.retrieve(
                                    query, max_results=5)

                                if results:
                                    st.write(
                                        "**Relevant documents from local corpus:**")
                                    for i, result in enumerate(results, 1):
                                        with st.expander(f"{i}. {result['title']} (score: {result['score']:.2f})"):
                                            st.write(
                                                f"**Path:** {result['url']}")
                                            if result['entities']:
                                                st.write(
                                                    f"**Entities:** {', '.join(result['entities'])}")
                                            st.write(
                                                f"**Content preview:** {result['content'][:500]}...")

                                    # Format as literature search result
                                    result = f"Found {
                                        len(results)} relevant documents in local corpus:\n\n"
                                    for i, doc in enumerate(results, 1):
                                        result += f"{i}. {doc['title']}\n"
                                        result += f"   Path: {doc['url']}\n"
                                        if doc['entities']:
                                            result += f"   Key terms: {', '.join(doc['entities'][:3])}\n"
                                        result += "\n"
                                else:
                                    result = "No relevant documents found in local corpus."

                                st.write(result)

                            except Exception as e:
                                st.error(f"GraphRAG error: {str(e)}")
                                # Fallback to regular check_idea
                                if fast:
                                    result = den.check_idea_fast(verbose=True)
                                else:
                                    result = den.check_idea()
                                st.write(result)
                        elif "arXiv" in provider:
                            # arXiv path (academic papers)
                            try:
                                from .arxiv_rag import get_arxiv_retriever

                                # Get arXiv retriever
                                retriever = get_arxiv_retriever()

                                # Search for relevant papers
                                query = den.research.idea if hasattr(
                                    den.research, 'idea') else "cosmology research"
                                results = retriever.retrieve(
                                    query, max_results=5)

                                if results:
                                    st.write("**Relevant papers from arXiv:**")
                                    for i, result in enumerate(results, 1):
                                        with st.expander(f"{i}. {result['title']}"):
                                            st.write(
                                                f"**Authors:** {', '.join(result['authors'][:3])}")
                                            if result['arxiv_id']:
                                                st.write(
                                                    f"**arXiv ID:** {result['arxiv_id']}")
                                            if result['doi']:
                                                st.write(
                                                    f"**DOI:** https://doi.org/{result['doi']}")
                                            st.write(
                                                f"**URL:** {result['url']}")
                                            if result['categories']:
                                                st.write(
                                                    f"**Categories:** {', '.join(result['categories'])}")
                                            st.write(
                                                f"**Abstract:** {result['content'][:300]}...")

                                    # Format as literature search result
                                    result = f"Found {
                                        len(results)} relevant papers from arXiv:\n\n"
                                    for i, doc in enumerate(results, 1):
                                        result += f"{i}. {doc['title']}\n"
                                        result += f"   Authors: {', '.join(doc['authors'][:3])}\n"
                                        if doc['arxiv_id']:
                                            result += f"   arXiv ID: {
                                                doc['arxiv_id']}\n"
                                        if doc['doi']:
                                            result += f"   DOI: https://doi.org/{
                                                doc['doi']}\n"
                                        result += f"   URL: {doc['url']}\n"
                                        result += f"   Abstract: {doc['content'][:200]}...\n\n"
                                else:
                                    result = "No relevant papers found on arXiv."

                                st.write(result)

                            except Exception as e:
                                st.error(f"arXiv search error: {str(e)}")
                                # Fallback to regular check_idea
                                if fast:
                                    result = den.check_idea_fast(verbose=True)
                                else:
                                    result = den.check_idea()
                                st.write(result)
                        else:
                            # Domain RAG path (Planck/CAMB/CLASSY)
                            # Enhanced with domain-specific context
                            if fast:
                                result = den.check_idea_fast(verbose=True)
                            else:
                                result = den.check_idea()

                            # Add domain-specific context to the result
                            domain_context = _get_domain_context(provider)
                            if domain_context:
                                result = f"{result}\n\n--- Domain Context ---\n{domain_context}"

                            st.write(result)

                        # --- HITL: citation review/edit/save ---
                        try:
                            from pathlib import Path as _Path
                            import re as _re

                            # Attempt to extract citations list
                            citations_text = ""
                            if isinstance(result, dict):
                                # Common shapes: {"citations": [...] } or
                                # {"results": {"citations": [...]}}
                                if "citations" in result and isinstance(
                                    result["citations"], list
                                ):
                                    citations_text = "\n".join(
                                        str(x) for x in result["citations"]
                                    )
                                elif (
                                    "results" in result
                                    and isinstance(result["results"], dict)
                                    and isinstance(
                                        result["results"].get("citations"),
                                        list,
                                    )
                                ):
                                    citations_text = "\n".join(
                                        str(x)
                                        for x in result["results"]["citations"]
                                    )
                                else:
                                    citations_text = str(result)
                            else:
                                citations_text = str(result)

                            # Light URL hint to help editing
                            urls = _re.findall(
                                r"https?://[^\s)]+", citations_text
                            )
                            if urls:
                                st.caption(
                                    f"Detected {
                                        len(urls)} URL(s) in results; you can edit below before saving.")

                            st.markdown("---")
                            st.write(
                                "Review and edit citations (one per line)."
                            )
                            edited_citations = st.text_area(
                                "Edit citations",
                                value=citations_text,
                                height=160,
                                key="editable_citations_area",
                            )

                            col_cit_a, col_cit_b = st.columns([1, 3])
                            with col_cit_a:
                                if st.button(
                                    "Accept citations",
                                    key="accept_citations_btn",
                                ):
                                    import json as _json

                                    out_dir = _Path(
                                        "/data/cmbagents/ragbook/docs/faber2025/refs_selected"
                                    )
                                    out_dir.mkdir(parents=True, exist_ok=True)
                                    # Build structured citations: title/url/doi
                                    # per line if possible
                                    raw_lines = [
                                        line_str.strip()
                                        for line_str in edited_citations.split(
                                            "\n"
                                        )
                                        if line_str.strip()
                                    ]
                                    structured = []
                                    for line in raw_lines:
                                        entry = {
                                            "title": None,
                                            "url": None,
                                            "doi": None,
                                        }
                                        # 1) Try JSON line
                                        try:
                                            obj = _json.loads(line)
                                            if isinstance(obj, dict):
                                                entry.update(
                                                    {
                                                        "title": obj.get(
                                                            "title"
                                                        ),
                                                        "url": obj.get("url"),
                                                        "doi": obj.get("doi"),
                                                    }
                                                )
                                                structured.append(entry)
                                                continue
                                        except Exception:
                                            pass
                                        # 2) Heuristics: extract URL and DOI,
                                        # rest as title
                                        _url_match = _re.search(
                                            r"https?://[^\s)]+", line
                                        )
                                        _doi_match = _re.search(
                                            r"10\.\d{4,9}/[-._;()/:A-Za-z0-9]+", line, )
                                        url_val = (
                                            _url_match.group(0)
                                            if _url_match
                                            else None
                                        )
                                        doi_val = (
                                            _doi_match.group(0)
                                            if _doi_match
                                            else None
                                        )
                                        # Remove url and doi from title text
                                        title_text = line
                                        if url_val:
                                            title_text = title_text.replace(
                                                url_val, ""
                                            ).strip()
                                        if doi_val:
                                            title_text = title_text.replace(
                                                doi_val, ""
                                            ).strip(" .;,-")
                                        entry["title"] = title_text or None
                                        entry["url"] = url_val
                                        entry["doi"] = doi_val
                                        structured.append(entry)

                                    # Write both JSON and a flat .md for
                                    # convenience
                                    out_json = (
                                        out_dir / "citations_selected.json"
                                    )
                                    with open(out_json, "w") as jf:
                                        jf.write(
                                            _json.dumps(structured, indent=2)
                                        )

                                    out_md = out_dir / "citations_selected.md"
                                    with open(out_md, "w") as mf:
                                        for e in structured:
                                            title_val = (
                                                e.get("title") or ""
                                            ).strip()
                                            doi_val = (
                                                e.get("doi") or ""
                                            ).strip()
                                            url_val = (
                                                e.get("url") or ""
                                            ).strip()
                                            doi_url = (
                                                f"https://doi.org/{doi_val}"
                                                if doi_val
                                                else None
                                            )

                                            line = title_val
                                            if doi_url:
                                                line += f" DOI: {doi_url}"
                                            if url_val and (
                                                not doi_url
                                                or url_val != doi_url
                                            ):
                                                line += f" {url_val}"
                                            mf.write(line.strip() + "\n")

                                    # Also emit a simple BibTeX file
                                    def _slugify(text: str) -> str:
                                        import re as __re

                                        return __re.sub(
                                            r"[^A-Za-z0-9]+", "", text
                                        )[:50]

                                    out_bib = (
                                        out_dir / "citations_selected.bib"
                                    )
                                    with open(out_bib, "w") as bf:
                                        for e in structured:
                                            title_val = (
                                                e.get("title") or ""
                                            ).strip()
                                            doi_val = (
                                                e.get("doi") or ""
                                            ).strip()
                                            url_val = (
                                                e.get("url") or ""
                                            ).strip()

                                            # BibTeX key preference: DOI-based
                                            # else title slug
                                            if doi_val:
                                                bib_key = _slugify(doi_val)
                                            elif title_val:
                                                bib_key = _slugify(title_val)
                                            else:
                                                bib_key = "ref"  # fallback

                                            bf.write(
                                                "@misc{" + bib_key + ",\n"
                                            )
                                            if title_val:
                                                bf.write(
                                                    "  title = {"
                                                    + title_val
                                                    + "},\n"
                                                )
                                            if doi_val:
                                                bf.write(
                                                    "  doi = {"
                                                    + doi_val
                                                    + "},\n"
                                                )
                                            if doi_val:
                                                bf.write(
                                                    "  url = {https://doi.org/"
                                                    + doi_val
                                                    + "},\n"
                                                )
                                            elif url_val:
                                                bf.write(
                                                    "  url = {"
                                                    + url_val
                                                    + "},\n"
                                                )
                                            bf.write(
                                                "  note = {Generated by DenarioApp HITL citation review}\n"
                                            )
                                            bf.write("}\n\n")

                                    st.success(
                                        f"Saved reviewed citations to "
                                        f"{out_json}, {out_md}, and {out_bib}"
                                    )
                        except Exception as _e:
                            st.warning(f"Citation review UI error: {str(_e)}")

                        if (
                            st.session_state.literature_running
                        ):  # Only show success if not stopped
                            st.success("Literature search completed!")
                    except Exception as e:
                        st.error(f"Error: {str(e)}")
                    finally:
                        st.session_state.literature_running = False

    except FileNotFoundError:
        st.write("Need to generate an idea first.")


def keywords_comp(den: Denario) -> None:

    st.header("Keywords")
    st.write("Generate keywords from your research text.")

    input_text = st.text_area(
        "Enter your research text to extract keywords:",
        placeholder="Multi-agent systems (MAS) utilizing multiple Large Language Model agents with Retrieval Augmented Generation and that can execute code locally may become beneficial in cosmological data analysis. Here, we illustrate a first small step towards AI-assisted analyses and a glimpse of the potential of MAS to automate and optimize scientific workflows in Cosmology. The system architecture of our example package, that builds upon the autogen/ag2 framework, can be applied to MAS in any area of quantitative scientific research. The particular task we apply our methods to is the cosmological parameter analysis of the Atacama Cosmology Telescope lensing power spectrum likelihood using Monte Carlo Markov Chains. Our work-in-progress code is open source and available at this https URL.",
        height=200,
    )

    n_keywords = st.slider(
        "Number of keywords to generate:", min_value=1, max_value=10, value=5
    )

    # Initialize session state for tracking operations
    if "keywords_running" not in st.session_state:
        st.session_state.keywords_running = False

    col1, col2 = st.columns([1, 1])
    with col1:
        press_button = st.button(
            "Generate Keywords",
            type="primary",
            key="get_keywords",
            disabled=st.session_state.keywords_running,
        )
    with col2:
        stop_button = st.button(
            "Stop",
            type="secondary",
            key="stop_keywords",
            disabled=not st.session_state.keywords_running,
        )

    # Add custom CSS for red border on stop button
    st.markdown(
        """
        <style>
        div[data-testid="column"]:nth-of-type(2) button {
            border: 2px solid #ff4444 !important;
            color: #ff4444 !important;
        }
        div[data-testid="column"]:nth-of-type(2) button:hover {
            background-color: #ff4444 !important;
            color: white !important;
        }
        </style>
    """,
        unsafe_allow_html=True,
    )

    if press_button and input_text and not st.session_state.keywords_running:
        st.session_state.keywords_running = True
        st.rerun()
    elif press_button and not input_text:
        st.warning("Please enter some text to generate keywords.")

    if stop_button and st.session_state.keywords_running:
        st.session_state.keywords_running = False
        st.warning("Operation stopped by user.")
        st.rerun()

    if st.session_state.keywords_running and input_text:
        with st.spinner("Generating keywords..."):
            try:
                den.get_keywords(input_text, n_keywords=n_keywords)

                if (
                    st.session_state.keywords_running
                ):  # Only show success if not stopped
                    generated_kw = st.session_state.get('generated_keywords')
                    if ((hasattr(den.research, "keywords")
                         and den.research.keywords) or generated_kw):
                        # Persist latest generated keywords in session to
                        # survive reruns
                        if hasattr(
                                den.research,
                                "keywords") and den.research.keywords:
                            st.session_state['generated_keywords'] = den.research.keywords
                            generated_kw = den.research.keywords

                        st.success("Keywords generated!")
                        st.write("### Generated Keywords")
                        for keyword, url in (generated_kw or {}).items():
                            st.markdown(f"- [{keyword}]({url})")

                        # --- Simple HITL review: allow edit/accept ---
                        st.markdown("---")
                        st.write("Review and edit keywords (comma-separated).")
                        default_keywords = st.session_state.get(
                            "accepted_keywords",
                            ", ".join(
                                list(
                                    (st.session_state.get('generated_keywords') or getattr(
                                        den.research,
                                        'keywords',
                                        {}) or {}).keys())),
                        )
                        editable_keywords = st.text_area(
                            "Edit keywords",
                            value=default_keywords,
                            height=120,
                            key="editable_keywords_area",
                        )

                        col_a, col_b = st.columns([1, 3])
                        with col_a:
                            if st.button(
                                "Accept keywords", key="accept_keywords_btn"
                            ):
                                # Persist edited keywords to a simple markdown
                                # file for downstream use
                                edited_list = [
                                    k.strip()
                                    for k in editable_keywords.split(",")
                                    if k.strip()
                                ]
                                try:
                                    out_dir = Path(
                                        den.project_dir) / "input_files"
                                    out_dir.mkdir(parents=True, exist_ok=True)
                                    out_path = out_dir / "keywords_selected.md"
                                    with open(out_path, "w", encoding="utf-8") as f:
                                        f.write(
                                            "Keywords: "
                                            + ", ".join(edited_list)
                                            + "\n"
                                        )

                                    # Also persist to paper temp so writer reads
                                    # immediately
                                    paper_temp_dir = Path(
                                        den.project_dir) / "paper" / "temp"
                                    paper_temp_dir.mkdir(
                                        parents=True, exist_ok=True)
                                    keywords_tex = paper_temp_dir / "Keywords.tex"
                                    # Write a minimal LaTeX document so the paper reader
                                    # can extract text between
                                    # \begin{document}..\end{document}
                                    _kw = ", ".join(edited_list)
                                    _latex_doc = (
                                        "\\documentclass{article}\n"
                                        "\\usepackage{amsmath}\n"
                                        "\\begin{document}\n"
                                        f"{_kw}\n"
                                        "\\end{document}\n"
                                    )
                                    with open(keywords_tex, "w", encoding="utf-8") as f:
                                        f.write(_latex_doc)

                                    md_ok = out_path.exists() and out_path.stat().st_size > 0
                                    tex_ok = keywords_tex.exists() and keywords_tex.stat().st_size > 0

                                    # Keep accepted keywords visible in the UI
                                    st.session_state["accepted_keywords"] = ", ".join(
                                        edited_list)

                                    if md_ok and tex_ok:
                                        st.success(
                                            f"Saved reviewed keywords to {out_path} and {keywords_tex}")
                                        # Preview saved keywords from
                                        # paper/temp/Keywords.tex
                                        try:
                                            saved_kw = keywords_tex.read_text(
                                                encoding="utf-8"
                                            ).strip()
                                            st.caption(
                                                "Saved Keywords (paper/temp/Keywords.tex):"
                                            )
                                            st.code(saved_kw, language="latex")
                                        except Exception as preview_err:
                                            st.info(
                                                f"Keywords saved, but preview unavailable: {preview_err}")
                                    else:
                                        st.error(
                                            f"Keywords not fully saved. Exists: md={md_ok}, tex={tex_ok}.")
                                except Exception as save_err:
                                    st.error(
                                        f"Failed to save keywords: {
                                            type(save_err).__name__}: {save_err}")
                    else:
                        st.error(
                            "No keywords were generated. Please try again with different text."
                        )
            except Exception as e:
                st.error(f"Error: {str(e)}")
            finally:
                st.session_state.keywords_running = False

    # --- Persistent review/editor: always render outside generation branch ---
    try:
        project_dir = Path(den.project_dir)
        md_path = project_dir / "input_files" / "keywords_selected.md"

        # Seed editable text from, in order of priority:
        # 1) accepted keywords from session
        # 2) generated keywords from session
        # 3) existing keywords_selected.md on disk
        # 4) empty
        seed_csv = st.session_state.get("accepted_keywords", "")
        if not seed_csv:
            gen_kw = st.session_state.get('generated_keywords') or {}
            if isinstance(gen_kw, dict) and gen_kw:
                seed_csv = ", ".join(list(gen_kw.keys()))
        if not seed_csv and md_path.exists():
            try:
                content = md_path.read_text(encoding='utf-8')
                seed_csv = content.split(
                    ":", 1)[1].strip() if ":" in content else content.strip()
            except Exception:
                seed_csv = ""

        # Only render the review UI if we have something to show/edit
        if seed_csv:
            st.markdown("---")
            st.write("Review and edit keywords (comma-separated).")
            with st.form("keywords_review_form"):
                edited_csv = st.text_area(
                    "Edit keywords",
                    value=seed_csv,
                    height=120,
                    key="editable_keywords_review",
                )
                submitted = st.form_submit_button("Accept keywords")
                if submitted:
                    edited_list = [k.strip()
                                   for k in edited_csv.split(",") if k.strip()]
                    try:
                        out_dir = project_dir / "input_files"
                        out_dir.mkdir(parents=True, exist_ok=True)
                        out_path = out_dir / "keywords_selected.md"
                        with open(out_path, "w", encoding="utf-8") as f:
                            f.write(
                                "Keywords: " + ", ".join(edited_list) + "\n")

                        paper_temp_dir = project_dir / "paper" / "temp"
                        paper_temp_dir.mkdir(parents=True, exist_ok=True)
                        keywords_tex = paper_temp_dir / "Keywords.tex"
                        _kw = ", ".join(edited_list)
                        _latex_doc = (
                            "\\documentclass{article}\n"
                            "\\usepackage{amsmath}\n"
                            "\\begin{document}\n"
                            f"{_kw}\n"
                            "\\end{document}\n"
                        )
                        with open(keywords_tex, "w", encoding="utf-8") as f:
                            f.write(_latex_doc)

                        md_ok = out_path.exists() and out_path.stat().st_size > 0
                        tex_ok = keywords_tex.exists() and keywords_tex.stat().st_size > 0
                        st.session_state["accepted_keywords"] = ", ".join(
                            edited_list)

                        if md_ok and tex_ok:
                            st.success(
                                f"Saved reviewed keywords to {out_path} and {keywords_tex}")
                            try:
                                saved_kw = keywords_tex.read_text(
                                    encoding="utf-8").strip()
                                st.caption(
                                    "Saved Keywords (paper/temp/Keywords.tex):")
                                st.code(saved_kw, language='latex')
                            except Exception as preview_err:
                                st.info(
                                    f"Keywords saved, but preview unavailable: {preview_err}")
                        else:
                            st.error(
                                f"Keywords not fully saved. Exists: md={md_ok}, tex={tex_ok}.")
                    except Exception as save_err:
                        st.error(
                            f"Failed to save keywords: {
                                type(save_err).__name__}: {save_err}")
    except Exception:
        pass


def wolfram_hitl_review_comp():
    """HITL review component for Wolfram Alpha ambiguous results."""

    st.subheader("🔍 Wolfram Alpha Review")
    st.write("Review ambiguous mathematical results that need human input.")

    # Initialize session state for HITL queue
    if 'wolfram_hitl_queue' not in st.session_state:
        st.session_state.wolfram_hitl_queue = []

    if 'wolfram_hitl_responses' not in st.session_state:
        st.session_state.wolfram_hitl_responses = {}

    # Display pending reviews
    if st.session_state.wolfram_hitl_queue:
        st.write(
            f"**{len(st.session_state.wolfram_hitl_queue)} pending reviews**")

        for i, review_item in enumerate(st.session_state.wolfram_hitl_queue):
            with st.expander(f"Review {i + 1}: {review_item.get('query', 'Unknown query')[:50]}...", expanded=True):
                st.write(f"**Query:** {review_item['query']}")

                # Display results
                if 'results' in review_item:
                    structured = review_item['results']

                    if structured.get('plaintext'):
                        st.write("**Plaintext Results:**")
                        for pt in structured['plaintext'][:3]:
                            st.code(pt)

                    if structured.get('latex'):
                        st.write("**LaTeX Results:**")
                        for latex in structured['latex'][:2]:
                            st.code(latex, language='latex')

                    if structured.get('assumptions'):
                        st.write("**Assumptions:**")
                        for assumption in structured['assumptions'][:2]:
                            st.write(f"- {assumption}")

                # Review options
                col1, col2, col3 = st.columns(3)

                with col1:
                    if st.button(f"✅ Approve {i + 1}", key=f"approve_{i}"):
                        st.session_state.wolfram_hitl_responses[review_item['id']] = {
                            'action': 'approve',
                            'selected_result': structured['plaintext'][0] if structured.get('plaintext') else None
                        }
                        st.session_state.wolfram_hitl_queue.pop(i)
                        st.rerun()

                with col2:
                    if st.button(f"✏️ Edit {i + 1}", key=f"edit_{i}"):
                        st.session_state[f"editing_{i}"] = True

                with col3:
                    if st.button(f"❌ Reject {i + 1}", key=f"reject_{i}"):
                        st.session_state.wolfram_hitl_responses[review_item['id']] = {
                            'action': 'reject', 'reason': 'User rejected'}
                        st.session_state.wolfram_hitl_queue.pop(i)
                        st.rerun()

                # Edit mode
                if st.session_state.get(f"editing_{i}", False):
                    edited_result = st.text_area(
                        "Edit the result:",
                        value=structured['plaintext'][0] if structured.get('plaintext') else "",
                        key=f"edit_text_{i}")

                    col1, col2 = st.columns(2)
                    with col1:
                        if st.button(
                                f"💾 Save Edit {
                                    i + 1}",
                                key=f"save_edit_{i}"):
                            st.session_state.wolfram_hitl_responses[review_item['id']] = {
                                'action': 'edit', 'edited_result': edited_result}
                            st.session_state.wolfram_hitl_queue.pop(i)
                            st.session_state[f"editing_{i}"] = False
                            st.rerun()

                    with col2:
                        if st.button(
                                f"❌ Cancel Edit {
                                    i + 1}",
                                key=f"cancel_edit_{i}"):
                            st.session_state[f"editing_{i}"] = False
                            st.rerun()

    else:
        st.info("No pending Wolfram Alpha reviews.")

    # Test Wolfram Alpha integration
    st.subheader("🧪 Test Wolfram Alpha")

    test_query = st.text_input(
        "Test query:",
        value="integrate x^2 from 0 to 1")

    if st.button("Test Query"):
        try:
            client = WolframAlphaClient(enable_hitl=True)
            result = client.query(test_query)

            if result.get("queryresult", {}).get("success"):
                primary_text = WolframAlphaClient.extract_primary_text(result)
                structured = WolframAlphaClient.extract_structured_results(
                    result)

                st.success("Query successful!")
                st.write(f"**Result:** {primary_text}")

                if structured.get('latex'):
                    st.write("**LaTeX:**")
                    st.code(structured['latex'][0], language='latex')

                # Check if HITL review is needed
                if client.needs_hitl_review(result):
                    st.warning("This result needs human review!")
                    hitl_prompt = client.get_hitl_prompt(test_query, result)
                    st.text_area("HITL Prompt:", value=hitl_prompt, height=100)
            else:
                st.error("Query failed")

        except Exception as e:
            st.error(f"Error: {str(e)}")


def add_wolfram_hitl_to_queue(
        query: str,
        wa_json: dict,
        review_id: str = None):
    """Add a Wolfram Alpha result to the HITL review queue."""
    if review_id is None:
        import uuid
        review_id = str(uuid.uuid4())

    structured = WolframAlphaClient.extract_structured_results(wa_json)

    review_item = {
        'id': review_id,
        'query': query,
        'results': structured,
        'timestamp': st.session_state.get('current_time', 'unknown')
    }

    if 'wolfram_hitl_queue' not in st.session_state:
        st.session_state.wolfram_hitl_queue = []

    st.session_state.wolfram_hitl_queue.append(review_item)
